#pragma config(UserModel, "C:/Users/rstudent/code/robot-configs/35.c")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!


#include <CKFlywheelSpeedController.h>



// A e^(B x)
// 1.2889 e 0.0925 x
#define A		1.2889
#define B		0.0925

#define Kq	0.05
#define Ki	0.03
#define Kd	0.0


// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// DON'T FORGET TO CHANGE!!!!!!!!!!!!!!
const bool iWantSpeedDial = true;





//Speeds are in radians/second of the motors's output drive shaft
const float MaxFlywheelSpeed = 16; // this should be a good max for high speed 393s
const float MinFlywheelSpeed = 8; // you can adjust this
const float FlywheelSpeedIncrement = 0.5; // each time you press the speed up/down buttons

// Best speeds you find via guess-n-check for close, mid, and far field shots
const float LowFlywheelSpeed = 9;
const float MidFlywheelSpeed = 12;
const float TopFlywheelSpeed = MaxFlywheelSpeed;



// You can change which buttons have which function,
// and the usercontrol code will just use these aliases.
/**********
#define BtnFlywheelOn					Btn8U
#define BtnFlywheelOff				Btn8D
#define BtnFlywheelFaster			Btn8R
#define BtnFlywheelSlower			Btn8L
**********/
#define BtnFlywheelTopSpeed		Btn8U
#define BtnFlywheelMidSpeed		Btn8L
#define BtnFlywheelLowSpeed		Btn8R
#define BtnFlywheelOff				Btn8D

#define BtnLiftDown						Btn5DXmtr2
#define BtnLiftUp							Btn5UXmtr2

#define BtnIntakeUp						Btn6U
#define BtnIntakeDown					Btn6D
#define BtnIntakeRollerIn			Btn5U
#define BtnIntakeRollerOut		Btn5D



FlywheelSpeedController flywheelController;
bool isFlywheelOn = true;//false;
float flywheelTargetSpeed = 0;



void drive(int left, int right){
	motor[leftDrive] = left;
	motor[rightDrive] = right;
}



// only give something if not in the "dead" zone
int livingJoy(int ch){
	int value = vexRT[ch];
	return abs(value) > 12 ? value : 0;
}



float speedDialValue(){
	// Use 16 because 16 radians/second is the nominal max speed
	// of high speed 393's output shaft.
	return 16*potentiometer(speedDial); //rad/sec of motor output shaft
}


void setLiftMotors( int power ){
	motor[liftLeft] = power;
	motor[liftRight] = power;
}




task FlywheelSpeedControl()
{
	while(true){
		// If isFlywheelOn==false then 0 will be passed in as the target speed,
		// effectively turning off the flywheel, without forgetting what the last
		// target speed was. When you turn it back on, it will go right back to
		// that same target speed because flywheelTargetSpeed is not modified
		// by turning on/off the flywheel.
		setTargetSpeed( flywheelController, isFlywheelOn ? flywheelTargetSpeed : 0 );

		// Recalculate the motor given to the flywheel motors.
		update( flywheelController );

		delay(40);
	}
}



//task LCDUpdate() {
//	string line0, line1;
//	float speedL, speedR;
//	float vExpander, vMain;

//	while(true){
//		delay(250);

//		speedL = getAverage( leftFlywheelController.maFlywheelSpeed );

//		vExpander = SensorValue[vPowerExpander] / 280.0;
//		vMain = MainBatteryVoltage();

//		sprintf(line0, "%.1f %.1f %.1f", flywheelTargetSpeed, speedL, speedR);
//		sprintf(line1, "%.2f %.2f", vExpander, vMain);
//		clearLCDLine(0);
//		displayLCDString(0, 0, line0);
//		clearLCDLine(1);
//		displayLCDString(1, 0, line1);
//	}
//}











/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	tMotor motorPorts[] = { mFly1, mFly2, mFly3, mFly4 };


	FlywheelSpeedControllerInit( flywheelController, Kq, Ki, Kd, A, B, motorPorts, 4 );

}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	startTask(FlywheelSpeedControl);

}




/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////



task usercontrol()
{
	startTask(FlywheelSpeedControl);

	time1[T1] = 0; // timer to govern the frequency of debug output

	while(true){

		motor[intakeUp] = buttonsToPower(BtnIntakeDown, BtnIntakeUp);
		motor[intakeRoller] = buttonsToPower(BtnIntakeRollerOut, BtnIntakeRollerIn);

		// Tank drive with joystick deadzone eliminated
		drive( livingJoy(ChJoyLY), livingJoy(ChJoyRY) );

		// -127 if 5d is pressed on ctlr 2 and +127 if 5u pressed on ctlr 2
		setLiftMotors( buttonsToPower(BtnLiftDown, BtnLiftUp) );

		if( iWantSpeedDial ){
			flywheelTargetSpeed = speedDialValue();
			if( time1[T1] > 250 ){
				writeDebugStreamLine( "Target: %.2f\tActual: %.2f", flywheelTargetSpeed, getMeasuredSpeed(flywheelController) );
				time1[T1] = 0;
			}
		}

		/********************
		bool turnOnFlywheel = (bool)vexRT[BtnFlywheelOn];
		bool turnOffFlywheel = (bool)vexRT[BtnFlywheelOff];

		if( turnOnFlywheel ){
			isFlywheelOn = true;
		} else if( turnOffFlywheel ){
			isFlywheelOn = false;
		}

		bool flywheelFaster = (bool)vexRT[BtnFlywheelFaster];
		bool flywheelSlower = (bool)vexRT[BtnFlywheelSlower];

		// Now with these guys, we need to avoid the unintended multi-press...
		if( flywheelFaster || flywheelSlower ){

			// Either going up or down by FlywheelSpeedIncrement.
			flywheelTargetSpeed += FlywheelSpeedIncrement * (flywheelFaster ? +1 : -1);

			// Make sure it stays in our predefined bounds
			flywheelTargetSpeed = bound( flywheelTargetSpeed, MinFlywheelSpeed, MaxFlywheelSpeed );

			delay(250); // here's the multi-press avoidance
		}
		********************/

		// Preset speeds
		if( vexRT[BtnFlywheelLowSpeed] )
			flywheelTargetSpeed = LowFlywheelSpeed;
		else if( vexRT[BtnFlywheelMidSpeed] )
			flywheelTargetSpeed = MidFlywheelSpeed;
		else if( vexRT[BtnFlywheelTopSpeed] )
			flywheelTargetSpeed = TopFlywheelSpeed;
		else if( vexRT[BtnFlywheelOff] )
			flywheelTargetSpeed = 0;

		delay(20);
	}

}
