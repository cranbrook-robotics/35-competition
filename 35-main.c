#pragma config(UserModel, "C:/Users/rstudent/code/robot-configs/35.c")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!


#include <CKFlywheelSpeedController.h>


#define IWantInrementalControls		0 // 1: yes, 0: no


// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
// DON'T FORGET TO CHANGE!!!!!!!!!!!!!!
const bool iWantSpeedDial = false;





//Speeds are in radians/second of the motors's output drive shaft

const float MaxFlywheelSpeed = 7.9; // this should be a good max for high speed 393s
const float MinFlywheelSpeed = 5.8; // you can adjust this

#if( IWantInrementalControls )
	const float FlywheelSpeedIncrement = 0.5; // each time you press the speed up/down buttons
#endif

// Best speeds you find via guess-n-check for close, mid, and far field shots
const float LowFlywheelSpeed = 5.6;
const float MidFlywheelSpeed = 7.9;
const float TopFlywheelSpeed = MaxFlywheelSpeed;



// You can change which buttons have which function,
// and the usercontrol code will just use these aliases.

#define BtnFlywheelTopSpeed		Btn8U
#define BtnFlywheelMidSpeed		Btn8L
#define BtnFlywheelLowSpeed		Btn8R
#define BtnFlywheelOff				Btn8D

#if( IWantInrementalControls )
	#define BtnFlywheelOn					Btn7U
	#define BtnFlywheelOff				Btn7D
	#define BtnFlywheelFaster			Btn7R
	#define BtnFlywheelSlower			Btn7L
#endif


#define BtnLiftDown						Btn5DXmtr2
#define BtnLiftUp							Btn5UXmtr2

#define BtnIntakeChainUp			Btn6U
#define BtnIntakeChainDown		Btn6D
#define BtnIntakeRollerIn			Btn5U
#define BtnIntakeRollerOut		Btn5D



FlywheelSpeedController leftFly, rightFly;
bool isFlywheelOn = false;
float flywheelTargetSpeed = 0;


///////////////////////////////////////////////////////////


void drive(int left, int right){
	motor[leftDrive] = left;
	motor[rightDrive] = right;
}



// only give something if not in the "dead" zone
int livingJoy(int ch){
	int value = vexRT[ch];
	return absolute(value) > 12 ? value : 0;
}



float speedDialValue(){
	// Use 16 because 16 radians/second is the nominal max speed
	// of high speed 393's output shaft.
	// 11 for standard (toruqe)
	return 11*potentiometer(speedDial); //rad/sec of motor output shaft
}


// void setLiftMotors( int power ){
// 	motor[liftLeft] = power;
// 	motor[liftRight] = power;
// }




task FlywheelSpeedControl()
{
	while(true){
		// If isFlywheelOn==false then 0 will be passed in as the target speed,
		// effectively turning off the flywheel, without forgetting what the last
		// target speed was. When you turn it back on, it will go right back to
		// that same target speed because flywheelTargetSpeed is not modified
		// by turning on/off the flywheel.
		float speedToUse = isFlywheelOn ? flywheelTargetSpeed : 0;
		setTargetSpeed( leftFly, speedToUse );
		setTargetSpeed( rightFly, speedToUse );

		// Recalculate the motor given to the flywheel motors.
		update( leftFly );
		update( rightFly );

		delay(40);
	}
}



//task LCDUpdate() {
//	string line0, line1;
//	float speedL, speedR;
//	float vExpander, vMain;

//	while(true){
//		delay(250);

//		speedL = getAverage( leftFlywheelController.maFlywheelSpeed );

//		vExpander = SensorValue[vPowerExpander] / 280.0;
//		vMain = MainBatteryVoltage();

//		sprintf(line0, "%.1f %.1f %.1f", flywheelTargetSpeed, speedL, speedR);
//		sprintf(line1, "%.2f %.2f", vExpander, vMain);
//		clearLCDLine(0);
//		displayLCDString(0, 0, line0);
//		clearLCDLine(1);
//		displayLCDString(1, 0, line1);
//	}
//}











/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// 1: front, 2: back, 3: above (with IME)
	const int MotorsPerFlywheel = 3;
	tMotor LFlyPorts[MotorsPerFlywheel] = { mFlyL1, mFlyL2, mFlyL3 };
	tMotor RFlyPorts[MotorsPerFlywheel] = { mFlyR1, mFlyR2, mFlyR3 };

	// Standard internal gearbox (aka torque) is the default, so you don't need to pass that
	// in if you're using standard.
	FlywheelSpeedControllerInit( leftFly, 1.288, 0.092, LFlyPorts, MotorsPerFlywheel );
	FlywheelSpeedControllerInit( rightFly, 1.288, 0.092, RFlyPorts, MotorsPerFlywheel );

	// Got the IMEs attached to the upper motor of each flywheel.
	setMotorPortOfIME( leftFly, mFlyL3 );
	setMotorPortOfIME( rightFly, mFlyR3 );

	// You probably want the left & right gains to be the same
	leftFly.Kq = rightFly.Kq = 0.05;
	leftFly.Ki = rightFly.Ki = 0.01; // keep this small for now
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	startTask(FlywheelSpeedControl);
	while(1)
	{
		flywheelTargetSpeed = MidFlywheelSpeed;
		wait1Msec(2000);
		motor[intakeUp] = 127;
		motor[intakeRoller] = 127;


	}
}






/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////



task usercontrol()
{
	startTask(FlywheelSpeedControl);

	time1[T1] = 0; // timer to govern the frequency of debug output

	while(true){

		motor[intakeUp] = buttonsToPower(BtnIntakeChainDown, BtnIntakeChainUp);
		motor[intakeRoller] = buttonsToPower(BtnIntakeRollerOut, BtnIntakeRollerIn);

		// Tank drive with joystick deadzone eliminated
		drive( livingJoy(ChJoyLY), livingJoy(ChJoyRY) );

		// -127 if 5d is pressed on ctlr 2 and +127 if 5u pressed on ctlr 2
		// setLiftMotors( buttonsToPower(BtnLiftDown, BtnLiftUp) );

		if( iWantSpeedDial ){
			flywheelTargetSpeed = speedDialValue();
			if( time1[T1] > 250 ){
				writeDebugStreamLine( "Target: %.2f \tL: %.2f \tR: %.2f",
						flywheelTargetSpeed, getMeasuredSpeed(leftFly), getMeasuredSpeed(rightFly)
				);
				time1[T1] = 0;
			}
		}

#if( IWantInrementalControls )
		bool turnOnFlywheel = (bool)vexRT[BtnFlywheelOn];
		bool turnOffFlywheel = (bool)vexRT[BtnFlywheelOff];

		if( turnOnFlywheel ){
			isFlywheelOn = true;
		} else if( turnOffFlywheel ){
			isFlywheelOn = false;
		}

		bool flywheelFaster = (bool)vexRT[BtnFlywheelFaster];
		bool flywheelSlower = (bool)vexRT[BtnFlywheelSlower];

		// Now with these guys, we need to avoid the unintended multi-press...
		if( flywheelFaster || flywheelSlower ){

			// Either going up or down by FlywheelSpeedIncrement.
			flywheelTargetSpeed += FlywheelSpeedIncrement * (flywheelFaster ? +1 : -1);

			// Make sure it stays in our predefined bounds
			flywheelTargetSpeed = bound( flywheelTargetSpeed, MinFlywheelSpeed, MaxFlywheelSpeed );

			delay(250); // here's the multi-press avoidance
		}
#endif

		// Preset speeds
		if( vexRT[BtnFlywheelLowSpeed] )
			flywheelTargetSpeed = LowFlywheelSpeed;
		else if( vexRT[BtnFlywheelMidSpeed] )
			flywheelTargetSpeed = MidFlywheelSpeed;
		else if( vexRT[BtnFlywheelTopSpeed] )
			flywheelTargetSpeed = TopFlywheelSpeed;
		else if( vexRT[BtnFlywheelOff] )
			flywheelTargetSpeed = 0;

		delay(20);
	}

}
